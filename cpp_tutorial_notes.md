# 0. Introduction

## C++ and CPP origins
C++ is one of the successors of C. Before C, most OS were written in Assembly. C was much better than Assembly and thus replaced as the de facto low level programming language for engineers. However, it lacked certain features as the tech market grew, the main being OOP construct. That is where C++ came in. C++ is also known as "C with class" and it was developed on Unix. C++ is perhaps best thought of as a superset of C, though this is not strictly true (as C99 introduced a few features that do not exist in C++).

The plus symbols can't be used in some situations, like in file names. Thus C++ is also known as CPP. File extensions that has .cpp are built with C++ source code. DOS and Windows C++ compilers use this file extension. 

The plus symbols can't be used in some situations, like in file names. Thus C++ is also known as CPP. File extensions that has .cpp are built with C++ source code. DOS and Windows C++ compilers use this file extension. 

## Application
C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of applications that most likely would be written in C++:

- Video games
- Real-time systems (e.g. for transportation, manufacturing, etc…
- High-performance financial applications (e.g. high frequency trading)
- Graphical applications and simulations
- Productivity / office applications
- IOT embedded software
- Audio and video processing
- Artificial intelligence and neural networks

In computer graphics, computer generated media tends to be structured, opposite of random and chaotic real life things.
CPP is also the GNU pre-processor.

## C++ compiling
In order to compile a C++ program, we use a C++ compiler. The C++ compiler sequentially goes through each source code in the **.cpp** file in your program. The compiler checks for errors and whether the source code compiles. Afterwards it translates the source code into a machine language file, called *object file*. Object files are typically named name.o or name.obj.

## Linker 
After the compiler creates one or more object files, then another program called the linker kicks in. The job of the linker is three fold:
1. Take all the object files generated by the compiler and combine them into a single executable program.
2. Link core and external libraries.
3. Make sure all cross-file dependencies are resolved properly

## Header files
Compilation in C++ is done in 2 major phases.
1. Compile the *source* text files into binary object files. The **.cpp** is the source text file and is compiled into a **.obj** object file. There may be multiple source text files but they are compiled without any knowledge of the other cpp files.
2. The object files are linked together and the final binary file is created. 

Because the files are compiled individually, the compiler has no knowledge of what names are declared in other compilation units. If those declarations are used in other cpp files as dependencies, they must be declared exactly the same in each cpp files that uses it. A slight inconsistency will cause errors, when the linker attempts to merge all the compilation units into a single program. 

To minimize the potential for errors, C++ has adopted the convention of using *header* files to contain declarations. You make the declarations in a header file, then use the *#include* directive in every .cpp file or other header file that requires that declaration. The *#include* directive inserts a copy of the header file directly into the .cpp file prior to compilation. It is suffixed by **.h** or **.hxx** or **.hpp**. 

Each separate source text file should have a header text file. It is good practice for a source file to include by default its own header file. There are *#include guards* in headers, which are used to check if a unique value (FRACTION_H) is defined. If it is not defined, it defines it and continues to the rest of the page. This is prevent double declaration of any user-type identifiers.

```
    #ifndef FRACTION_H
    #define FRACTION_H

    // Define a new type named Fraction
    // This only defines what a Fraction looks like, it doesn't create one
    // Note that this is a full definition, not a forward declaration
    struct Fraction
    {
        int numerator {};
        int denominator {};
    };

    #endif
```

## Library
C++ also comes with an extensive library called the C++ Standard Library (usually shortened to standard library) that provides additional functionality that you can use in your programs. One of the most commonly used parts of the C++ standard library is the **iostream** library, which contains functionality for printing text on a monitor and getting keyboard input from a user. 

Almost every C++ program written utilizes the standard library in some form, so it’s very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn’t something you need to worry about.

## IDE
Install an IDE that comes with the latest C++ compiler. If not make sure it is at least has a C++17 capable compiler.

## Build Configuration
A build configuration or build target are configuration settings that determines how your project will be built. This includes basic things such as:

- name of executable file
- directories for IDE to look for libraries
- keep or strip debugging information
- level of optimization the compiler should check for

It is normally best to leave these at the default settings. There are two types of build configurations:

- Release configuration
- Debug configuration

Release configuration are settings to release code in production. Strips all debugging information but includes all the optimization methods for performance and size. Useful for performance testing the application in production. 
Debug configuration are settings to help debug your program. Turns off all optimization methods and includes the debugging information. This makes the program larger and slower but easier to debug. The debugging information is quite big and the difference between including and excluding it is quite substantial.

The build configuration type can easily be switched at the tool bar of your IDE which is usually at the top middle.

## Compiler Configuration

### Compiler Extensions
The standard C++ defines rules about how programs should behave in specific circumstances. While compilers follow these instructions most of the times, sometimes they will implement their own changes to the language. The purpose is to enhance compatibility with other versions of the language (e.g. C99). These compiler specific behaviors are called *compiler extensions*.

When you write a program with the compiler extension enabled, the program will be incompatible with the C++ standard. Programs that make use of non-standard extensions generally will not compile on other compilers that don't support these extensions. Even if they do, they may not run correectly. 

Keep in mind that compiler extensions are enabled by default. Thus unless you have a specific reason to use a certain compiler extension, they are not recommnded as they are non-compliant with C++ standards. They should be turned off at the start of the project. This will allow the program to be compliant with C++ standards and work on any system.

### Warning and Errors
If you have turned the compiler extensions off, the compiler will check if you follow the standard C++ rules. The compiler will search and identitfy and errors you make. In some cases, the compiler may find code that seems like it might be an error but not sure. This will issue a warning instead of an error, as there is a motto **trust the programmer**, which states that the compiler shouldn't prevent the programmer from doing what needs to be done. Typos can also register as warnings but serious errors can also be warnings so don't ignore them. 

There are ways in IDE to temporarily disable warnings but this is not recommended.

The warning level can be raised or lowered, meaning the compiler will be more sensitive or more relaxed when identifying possible errors. When starting out C++, it is best to set the level to max to help identify possible issues. You can also configure the compiler to treat warnings as errors. This is a good way to enforce programmers to fix all warnings, which many don't.

## C++ variations
There are many different versions of C++ (C++98, C++03, C++11, C++14, C++17, C++20, etc…). Your compiler will generally pick a standard to set as default. This is typically not the most recent language standard. To use a different language standard, you'll have to configure the IDE compiler to do so. 

Finalized language standards are named after the years in which they are finalized (e.g. C++17 was finalized in 2017). There are also in-progress language standards which are still in development and not clear in what year they will be finalized. For example, C++11 was caalled c++1x while it was under development.

In a professional environment, it is best to choose a language standard that is one or two versions back from the latest standard. As of this writing the latest version is C++20, thus you should choose C++14 or C++17. Several reasons to do this

- Compilers on some platforms may not provide full support for the latest standard right away
- Ensure the engineers have had the chance to fix any defects in the latest version 
- Allow best practices for new features to be discovered

In a learning environment, there is little downside to choosing the latest standard. 

As of the time of writing, Visual Studio 2022 defaults to C++14 capabilities, which does not allow for the use of newer features introduced in C++17 and C++20. To use these newer features, you’ll need to enable a newer language standard. Unfortunately, there is currently no way to do this globally -- you must do so on a project-by-project basis.

# 1. Basics

## Statement
A program is a sequence of instructions that tells the computer waht to do. A statement is a type of instruction that makes the program to do some action. 

Statements are the most common type of instruction in a C++ program. THey are the smallest unit of computation in C++. Most but not all statements in C++ end in a semicolon. Any line that ends in a semicolon is most likely a statement. 

This is in the context of C++. A single C++ statement may compile into dozens of machine language instructions.  

## main function
A function is a group of statements executed sequentially. A good developer will keep the size to a minimal and the logic as single as possible.

Just like Java, every C++ program must have a function called main. When the program is run all the statments inside of the main function are executed in sequential order. If the main function is absent from a program, it will compile but fail to build.

Example of main function in action:

    #include <iostream>

    int main()
    {
        std::cout << "Hello World!\n";
        return 0;
    }

There are quite a few syntax similarities to Java you see here.Some key terms to know from above:

- Line 1 is a special type of line called a **preprocessor directive**, indicates the use of **iostream** library contents
- Line 3 is the declaration of the main function, and indicates what type of data the function is returning
- Line 4 ~ 7 is the function body
- Line 5, 6 all have semicolons at the end, indiciating each of them are separate statements
- 

When compiled, the console will print the hello world statement and return 0.

## Comments
Comments exist soley for the programmer and devopers, as all comments are ignored by the compiler. Two types of comments:

- Single-line comments: begins with *//*. Typically used make a quick comment about a single line of code

Depending on the length, they can be either on the right side or the top of the code

- Multi-line comments: the /* and */ pair of symbols. Multi-line comments can't be nested.

Example:

    /* This is a multi-line comment.
    * the matching asterisks to the left
    * can make this easier to read
    */


## Objects
Like most programming langauges, direct memory access is discouraged and instead accessed indirectly via *object*. An object can be named or unnamed (anonymous). A named object is called a *variable* while the name of the object is called an *identifier*.

```
int x; // define a variable named x, of type int
```

Objects must be declared and a declaration statement is called a *definition*. 

At compile time, objects are not yet created but the compiler takes note that we are defining a certain variable with a certain name with its data type. Like Java the Object's data type must be known at compile time (static). 
At runtime, the object is created and assigned a memory address. This is called *instantiation* and an instantiated object is also called an *instance*.

## Declaration vs Definition
A *declaration* provides basic attributes of a symbol: its type and its name. A *definition* provides all of the details of that symbol -- if it's a function, what it does; if it's a class, what fields and methods it has; if it's a variable, where the variable gets stored. Thus memory for the variable is allocated during the definition of the variable.

In C language definition and declaration for a variable takes place at the same time. i.e. there is no difference between declaration and definition. 

## Defining multiple variables
It is possible to define multiple variables of the same type in a single statement by separating the names with a comma. The following code declares two variables of same integer type:

```
    int a, b;
```

You can't define variables of different types in the same statement. Variables of different types must be defined in separate statements.

```
    int a, double b; // wrong (compiler error)
    int a; double b; // correct (but not recommended)

    // correct and recommended (easier to read)
    int a;
    double b;
```

## Variable assignment and ininitialization
After defining a variable you can give it a value.

```
    #include <iostream>

    int main()
    {
        int width;
        width = 5; // copy assignment of value 5 into variable width

        // variable width now has value 5

        width = 7; // change value stored in variable width to 7

        // variable width now has value 7

        return 0;
    }
```

When no value is assigned to a value, it is called *default initializiation*. The variable references an undeterminate value. There are 4 basic ways to initialize variables in C++:
- default initializiation - nothing is assigned
- Copy initialization - assigned with =
- Direct initialization - assigned with ()
- Brace initialization - assigned with {}. modern way of initializing objects in C++

Declaration and initialization can be done on same one line:

```
    int a; // no initializer
    int b = 5; // initializer after equals sign
    int c( 6 ); // initializer in parenthesis
    int d { 7 }; // initializer in braces
```

Brace initialization doesn't allow *narrowing conversions*. This means that if you try to brace initialize a variable using a value that the variable can not safely hold, the compiler will produce an error. 

```
int width { 4.5 }; // error: a number with a fractional value can't fit into an int
```

If we tried copy and direct initialization, the compiler would simply drop the fractional part, resulting in the initialization of value 4 into variable width.'

## Value initialization and Zero initalization
When a variable is initialized with empty braces, *value initialization* takes place. In most cases, value initialization will initialize the variable to zero (or empty, if that’s more appropriate for a given type). 
This is useful when we want to create empty variables that is ready to accept an input.

*if a class is built-int, it will perform the same *value initialization*. But if the class is user-declared, it will invoke the dfault constructore.

## Multiple initialization
Like declarations, initialization of same types can be done on the same line. Keep in mind that all the variables on the line must be initialized, not just some:

```
    int a, b = 5; // wrong (a is not initialized!)
    int a = 5, b = 6; // copy initialization
    int c( 7 ), d( 8 ); // direct initialization
    int e { 9 }, f { 10 }; // brace initialization (preferred)
```

## IOStream library: output
As part of the C++ standard library that deals with IO. 

To print something, use *std::cout*, along with the *insertion operator* *<<,*

```
    #include <iostream> // for std::cout

    int main()
    {
        int x{ 5 };                         // define integer variable x, initialized with value 5
        std::cout << x;                     // print value of x (5) to console
        std::cout << "Hello" << " world!";  // print multiple things in one line
        return 0;
    }
```

Keep in mind that separate output statements don’t result in separate lines of output on the console. If we want to print separate lines of output to the console, we need to tell the console when to move the cursor to the next line using either  *std::endl* or the esacpe character '\n':

```
    #include <iostream> // for std::cout

    int main()
    {
        int x{ 5 };
        std::cout << "x is equal to: " << x << '\n';   // \n standalone, single quote needed
        std::cout << "And that's all, folks!\n";   // '\n' embedded, double quote needed
        return 0;
    }
```

For the standalone '\n', single quotes are needed. For the embedded '\n' above, double quotes are needed.

```
    #include <iostream> // for std::cout

    int main()
    {
        std::cout << "Hi!" << std::endl;
        std::cout << "My name is Alex." << std::endl;
        return 0;
    }
```

The second std::endl above isn’t technically necessary, since the program ends immediately afterward. However, it serves a few useful purposes:

- indicate that the line of output is a “complete thought” (as opposed to partial output that is completed somewhere later in the code). In this sense, it functions similarly to using a period in standard English.
- positions the cursor on the next line, so that if we later add additional lines of output (e.g. have the program say “bye!”), those lines will appear where we expect (rather then appended to the prior line of output).
- after running an executable from the command line, some operating systems do not output a new line before showing the command prompt again. If our program does not end with the cursor on a new line, the command prompt may appear appended to the prior line of output, rather than at the start of a new line as the user would expect.

*std::endl* does two jobs: it moves the cursor to the next line, and flushes the output. When writing text to the console using std::cout, std::cout often flushes output anyway. Thus we prefer *\n* and it is easier to read.

## IOStream library: input
*std::cin* (which stands for “character input”) reads input from keyboard using the *extraction operator* (>>). The input must be stored in a variable to be used thus this is where zero initialization comes in. Just like it is possible to output more than one bit of text in a single line, it is also possible to input more than one value on a single line:

```
    #include <iostream>  // for std::cout and std::cin

    int main()
    {
        std::cout << "Enter two number separated by a space: ";

        int x{ }; // define variable x to hold user input (and zero-initialize it)
        int y{ }; // define variable y to hold user input (and zero-initialize it)
        std::cin >> x >> y; 

        std::cout << "You entered " << x << " and " << y << '\n';
        return 0;
    }
```

Note that you don’t need to use ‘\n’ when accepting input, as the user will need to press the enter key to have their input accepted, and this will move the cursor to the next line.

*In line with our previous recommendation that *variables should always be initialized*, best practice is to initialize the variable first.

*The C++ I/O library does not provide a way to accept keyboard input without the user having to press enter. If this is something you desire, you’ll have to use a third party library.

## Initialized vs Uninitialized
C++ does not initialize most variables to a given value (zero) automatically. When a variable is given a memory address to store data, the default value is whatever garbage value that already happens to be in that memory address. A variable that hasn't been given a known value is called an uninitialied variable. 

Initialized is not the opposite of uninitialized. Initialized means the object was provided with an initial value at the time of definition and uninitilaized means the object has not been given a known value. If an uninitialized object is assigned a known value, it is no longer uninitialized. 

- Initialization = The object is given a known value at the point of definition.
- Assignment = The object is given a known value beyond the point of definition.
- Uninitialized = The object has not been given a known value yet.

This lack of initialization is a performance optimization inherited from C, back when computers were slow. Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.

If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (slow) and for little benefit (since you’re overwriting those values anyway).

For now, you should always initialize your variables because the cost of doing so is miniscule compared to the benefit. Once you are more comfortable with the language, there may be certain cases where you omit the initialization for optimization purposes. But this should always be done selectively and intentionally.

```
#include <iostream>

int main()
{
    // define an integer variable named x
    int x; // this variable is uninitialized because we haven't given it a value

    // print the value of x to the screen
    std::cout << x; // who knows what we'll get, because x is uninitialized

    return 0;
}
```

Most modern compilers will attempt to detect if a variable is being used without being given a value. The program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0. Otherwise, the compilers will be able to detect uninitialized variables, they will generally issue a compile-time error. For example, compiling the above program on Visual Studio produced the 'uninitialized local variable 'x' used' warning.

A nice trick to get around this is to make the compiler think we are assigning a value to the variable.

```
#include <iostream>

    void doNothing(int&) // does nothing
    {
    }

    int main()
    {
        // define an integer variable named x
        int x; // this variable is uninitialized

        doNothing(x); // make the compiler think we're assigning a value to this variable

        // print the value of x to the screen (who knows what we'll get, because x is uninitialized)
        std::cout << x;

        return 0;
    }
```

always initialize your variables!

## Undefined behavior
Using the value from an uninitialized variable is our first example of *undefined behavior*. Undefined behavior (often abbreviated UB) is the result of executing code whose behavior is not well defined by the C++ language. In this case, the C++ language doesn’t have any rules determining what happens if you use the value of a variable that has not been given a known value. Consequently, if you actually do this, undefined behavior will result.

Code implementing undefined behavior may exhibit any of the following symptoms:
- different results every time it is run.
- same incorrect result.
- inconsistent behavior (sometimes produces the correct result, sometimes not).
- seems like its working but produces incorrect results later in the program.
- program crashes, either immediately or later.
- program works on some compilers but not others.
- program works until you change some other seemingly unrelated code.

As a general rule of thumb, take care to avoid all situations that result in undefined behavior, such as using uninitialized variables.

## Keywords and Special identifiers
C++ has keywords and special identifiers: override, final, import, and module. While key words are reserved, special identifiers are not reserved. 

There are three different naming conventions:

- CamelCase
- snake_case
- pascalCase

C++ uses CamelCase like Java. 

Some things to keep in mind when naming:

- avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- avoid abbreviations
- avoid trivial an overly complex names

## Whitespace and Basic formatting
The C++ compiler generally ignores whitespaces thus we say that C++ is a whitespace-independent language. The following all do the exact same thing:

```
    std::cout << "Hello world!";

    std::cout               <<            "Hello world!";

            std::cout << 		"Hello world!";

    std::cout
        << "Hello world!";
```

For that reason, whitespaces and newlines are often used for code organization and readability.

The only exception is when whitespaces exist inside quoted text and comments. Newlines are not allowed in quoted text and comments:

```
    std::cout << "Hello
        world!"; // Not allowed!

    std::cout << "Hello "
        "world!"; // prints "Hello world!"

    std::cout << "Hello world!"; // Here is a single-line comment
    this is not part of the comment     
```

Because newlines and whitespaces only matter in quoted texts and comments, developers often do the following when declaring a function body: 

```
int main()
{
    std::cout << "Hello world!\n"; // tabbed in one tab (4 spaces)
    std::cout << "Nice to meet you.\n"; // tabbed in one tab (4 spaces)
}
```

Some more coding style conventions: 

- keep a single line no longer than 80 chars
- if the comment is above a code, there should be a new line above the comment
- if the comment is on the right hand side of the code, use whitespaces to align them
- use whitespace to make your code easier to read by aligning values

```
    cost          = 57;
    pricePerItem  = 24;
    value         = 5;
    numberOfItems = 17;
    std::cout << "Hello world!\n";                  // cout lives in the iostream library
    std::cout << "It is very nice to meet you!\n";  // these comments are easier to read
    std::cout << "Yeah!\n";                         // especially when all lined up

    // cout lives in the iostream library
    std::cout << "Hello world!\n";

    // these comments are easier to read
    std::cout << "It is very nice to meet you!\n";

    // when separated by whitespace
    std::cout << "Yeah!\n";
```

Using the automatic formatting feature is highly recommended to keep your code’s formatting style consistent. However, don't trust it completely as it sometimes may not choose the most readable formatting. Go over the code with your eyes for double checking. 

## Literals and Operators
A *literal* or a *constant* is a fixed value that has been directly inserted into the source code. Literals can't be changed while variable value's can be changed through initialization and assignment.

```
std::cout << "Hello world!";  // Hello world! is a literal
int x{ 5 };                   // 5 is a literal
```

Operators in C++ come in four different arities:

- Unary operators - act on one operand. An example is the negative operator
- Binary operators - act on two operands. The insertion (<<) and extraction (>>) operators are binary operators, taking std::cout or std::cin on the left side, and the value to output or variable to input to on the right side.
- Ternary operators - act on three operands. There is only one of these in C++ (the conditional operator), which we’ll cover later.
- Nullary operators - act on zero operands. There is also only one of these in C++ (the throw operator), which we’ll also cover later.

## Expression
An expression is a combination of literals, variables, operators, and function calls that *calculates a single value*. The process of executing an expression is called *evaluation*, and the single value produced is called the result of the expression.

Literals evaluate to their own values. 
Variables evaluate to the value of the variable.
Function calls evaluate to whatever value the function returns. 
Operators (such as operator+) let us combine multiple values together to produce a new value.

Expressions do not end in a semicolon, and cannot be compiled by themselves. Rather, expressions are always evaluated as part of statements. An *expression statement* is a statement that consists of an expression followed by a semicolon. When the statement is executed, the expression will be evaluated.

```
    // type identifier { expression };
    int x{ 2 + 3 };
```

An *expression statement* is a statement that consists of an expression followed by a semicolon. When the statement is executed, the expression will be evaluated.

An expression whose result is discarded is called a *discarded-value expression*. Expression statements are by far the most common type of discarded-value expressions.

# 2. Functions and Files

## Functions
A function is a reusable sequence of statements designed to do a particular job. Functions written yourself are called *user-defined functions*. When a function is called inside another FUNCTION, the CPU puts a bookmark at the current point of execution and executes the *called* function. When the called function ends, the CPU returns back to the point of book mark of the *caller* function and resumes execution.

The signature of the function is also called the *function header*.The curly braces and statements in-between are called the *function body*

Unlike some other languages like Python, C++ doesn't allow nested functions like the following:

```
    #include <iostream>

    int main()
    {
        void foo() // Illegal: this function is nested inside function main()
        {
            std::cout << "foo!\n";
        }

        foo(); // function call to foo()
        return 0;
    }
```

C++ disallows calling the main function explicitly and the main function should be at the bottom of your code module.

Functions should be minimal and only perform one type of action. If you see a block of code that is repeated, it is best to put that in a separate function and make calls to that function. This is follwoing the DRY best practice: *don’t repeat yourself*

```
    #include <iostream>
    int getValueFromUser() 
    {
        int input{};
        std::cout << "Enter an integer: ";
        std::cin >> input; 
        return input;
    }

    int main()
    {
        int x{ getValueFromUser() };
        int y{ getValueFromUser() };
        std::cout << x << " + " << y << " = " << x + y << '\n';
        return 0;
    }
```

## Return
C++ has a garbage collector for memory management. When a function terminates, all the value entered inside that function is lost. To save any data from that function, we have the *return* keyword to return a value or data. You can use that value in an expression or statement (by assigning to a variable or sending it somewhere). Otherwise it will be ignored. Functions with a return type are called *value-returning function*.

```
#include <iostream>

int getValueFromUser() // this function now returns an integer value
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value the user entered back to the caller
}

int main()
{
	int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

In the main function, a status code of 0 means the program executed successfully. 
In C++, a function can only return a single value.
*Early returns* are perfectly legal in C++:

```
#include <iostream>

int print() // note: return type of int
{
    std::cout << "A";
    return 5; // the function will return to the caller here
    std::cout << "B"; // this will never be printed
}

int main()
{
    std::cout << print(); // print() returns value 5, which will be print to the console

    return 0; // the final print is 'A5'
}
```

## Void functions
Functions that don't return a value are called *non-value returning function*. Technically you can put an empty return statement at the end of a void function but of course this is redundant. You will almost never see this in real life codes and only in theoretical exams.

```
#include <iostream>

// void means the function does not return a value to the caller
void printHi()
{
    std::cout << "Hi" << '\n';

    return; // tell compiler to return to the caller -- this is redundant since this will happen anyway!
} 

int main()
{
    printHi();

    return 0;
}
```

*Trying to return a value from a non-value returning function will result in a compilation error.

When we call a function in a context that requires a value (e.g. std::cout), a value must be provided. In such a context, we can only call value-returning functions. The compiler will throw an error if a value is not provided.  

```
void printHi()
{
    std::cout << "Hi" << '\n';
}

int main()
{
    std::cout << 5;             // ok: 5 is a literal value that we're sending to the console to be printed
    std::cout << ;              // compile error: no value provided
    std::cout << printHi();     // compile error: no value provided
    return 0;
}
```

## Parameter and Argument
A function *parameter* is a variable used in a function. They are always initialized with a value provided by the caller of the function. This value is called an *argument*.

When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is copied into the matching parameter. This process is called *pass by value*.

Sometimes, you may only use a variable once to hold a return value and then pass that variable's value to another function. In that case you can directly use the return value of the function as an argument to another function:

```
    printDouble(getValueFromUser());
```

This may be more compact a bit harder to read. If you think your code is going to be read often by other developers, you should first initalize the return value to a variable and then pass it as an argument. You can also save space by directly returning the value of the expression:

```
    int add(int x, int y)
    {
        return x + y;
    }
```

The following statements are all valid:

```
    std::cout << add(1, multiply(2, 3)) << '\n';    // evaluates 1 + (2 * 3)
    std::cout << add(1, add(2, 3)) << '\n';         // evaluates 1 + (2 + 3)
```

## Local scope
Function parameters and variables defined inside the function body are called *local variables*. As mentioned before, the local variables are garbage collected when the function ends, in the opposite order of creation.

```
    int add(int x, int y) // function parameters x and y are local variables, created and initialized here
    {
        int z{ x + y }; // z is a local variable too, created and initialized here

        return z;
    } // z, y, and x destroyed here
```

An object’s *lifetime* is defined to be the time between its creation and destruction. Variable creation and destruction happen during the program's runtime, not at compile time. Therefore, *lifetime is a runtime property*.

*The C++ specification gives compilers a lot of flexibility to determine when local variables are created and destroyed. Objects may be created earlier, or destroyed later for optimization purposes. Most often, local variables are created when the function is entered, and destroyed in the opposite order of creation when the function is exited.

An identifier’s scope determines where the identifier can be accessed within the source code. When an identifier can be accessed, we say it is *in scope*. When an identifier can not be accessed, we say it is *out of scope*. While a lifetime is a runtime property, a scope is a compile-time property.

```
    #include <iostream>

    int add(int x, int y) // x and y are created and enter scope here
    {
        // x and y are visible/usable within this function only
        return x + y;
    } // y and x go out of scope and are destroyed here

    int main()
    {
        int a{ 5 }; // a is created, initialized, and enters scope here
        int b{ 6 }; // b is created, initialized, and enters scope here

        std::cout << add(a, b) << '\n'; // calls function add() with x=5 and y=6

        return 0;
    } // b and a go out of scope and are destroyed here
```
*note that variables a and b are different variables from x and y.

An identifier is “out of scope” anywhere it can not be accessed within the code. The term “going out of scope” is typically applied to objects rather than identifiers. We say an object “goes out of scope” at the end of the scope (the end curly brace) in which the object was instantiated. 

Note that not all types of variables are destroyed when they *go out of scope*.

If a function was to be called twice, the parameters x and y would be created and destroyed twice -- once for each call. 

The following program, the 'add' variables x, y are distinct from 'main' variables x, y. Even though they have the same name, they have different scopes and just happen to share the same name.  

```
#include <iostream>

int add(int x, int y) // add's x and y are created and enter scope here
{
    // add's x and y are visible/usable within this function only
    return x + y;
} // add's y and x go out of scope and are destroyed here

int main()
{
    int x{ 5 }; // main's x is created, initialized, and enters scope here
    int y{ 6 }; // main's y is created, initialized, and enters scope here

    // main's x and y are usable within this function only
    std::cout << add(x, y) << '\n'; // calls function add() with x=5 and y=6

    return 0;
} // main's y and x go out of scope and are destroyed here
```

Names used for function parameters or variables declared in a function body are only visible within the function that declares them. This means local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent. 

As a general rule of thumb: local variables inside the function body should be defined as close to their first use as reasonable:



# Chapter 10

## User-defined types and Program-defined types
Consider the case of a type alias, which allows us to define a new name for an existing type. Because a type alias introduces a new identifier into the program, a type alias must be defined before it can be used:

```
    #include <iostream>

    using length = int; // define a type alias with identifier 'length'

    int main()
    {
        length x { 5 }; // we can use 'length' here since we defined it above
        std::cout << x;

        return 0;
    }
```

The definition doesn't create an object but merely tells the compiler what a *length* is. This is also true for *user-defined types* and its definition is called *type definition*. Below we first define what a *Fraction* is and then instantiate it in the *main* class.

```
// Define a program-defined type named Fraction so the compiler understands what a Fraction is
// This only defines what a Fraction type looks like, it doesn't create one
struct Fraction
{
	int numerator {};
	int denominator {};
};

// Now we can make use of our Fraction type
int main()
{
	Fraction f{ 3, 4 }; // this actually instantiates a Fraction object named f

	return 0;
}
```

Don’t forget to end your type definitions with a semicolon, otherwise the compiler will typically error on the next line of code. For example, if you remove the semicolon from the end of the Fraction definition (line 8) of the example above, the compiler will probably complain about the definition of main() (line 11).

A user-defined type is any type that is not part of the core C++ language, meaning the C++ standard library are technically also considered user-defined type. A program-defined type is a only a type that you've defined.

Every code file that uses a program-defined type needs to see the full type definition before it is used. This is required so that the compiler knows how much memory to allocate for objects of that type.

As mentioned before, program-defined types are typically defined in header files, and then *#included* into any code file that requires that type definition. These header files are typically given the same name as the program-defined type

```
#ifndef FRACTION_H
#define FRACTION_H

// Define a new type named Fraction
// This only defines what a Fraction looks like, it doesn't create one
// Note that this is a full definition, not a forward declaration
struct Fraction
{
	int numerator {};
	int denominator {};
};

#endif
```

User-defined types are exempt from the *one-definition* rule and can be propagated to multiple files.

## Enumerations
Enumeration or Enum is a compound data type where every possible value is defined as a symbolic constant, called enumerator. Enums are program-defined types thus need to be defined before we can use it. There are two types of enums:

- Unscoped enums
- Scoped enums

Enumerated types are best used when you have a smallish set of related constants, and objects only need to hold one of those values at a time.

```
    // Define a new unscoped enumeration named Color
    enum Color
    {
        // Each enumerator is separated by a comma, not a semicolon
        red,
        green,
        blue, // trailing comma optional but recommended
    }; // the enum definition must end with a semicolon

    int main()
    {
        // Define a few variables of enumerated type Color
        Color apple { red };   // my apple is red
        Color shirt { green }; // my shirt is green
        Color cup { blue };    // my cup is blue

        Color socks { white }; // error: white is not an enumerator of Color
        Color hat { 2 };       // error: 2 is not an enumerator of Color

        return 0;
    }
```

Enumerations don’t have to be named, but unnamed enumerations should be avoided in modern C++. The enumerators should be named all lower case.

Each enumerated type you create is considered to be a distinct type, meaning the compiler can distinguish it from other types (unlike typedefs or type aliases, which are considered non-distinct from the types they are aliasing). Therefore, enumerators defined as part of one enumerated type can’t be used with objects of another enumerated type:

```
    int main()
    {
        Pet myPet { black }; // compile error: black is not an enumerator of Pet
        Color shirt { pig }; // compile error: pig is not an enumerator of Color

        return 0;
    }
```

Enums have a variety of good uses, such as error codes or game items:

```
enum FileReadResult
{
    readResultSuccess,
    readResultErrorFileOpen,
    readResultErrorFileRead,
    readResultErrorFileParse,
};

enum ItemType
{
    sword,
    torch,
    arrow,
};

enum SortOrder
{
    alphabetical,
    alphabeticalReverse,
    numerical,
}
```

While many languages use enums to define Booleans, C++ define Booleans as keywords instead of enums.

If th ere are two enumerators of the same name in the same scope, this leads to a naming collision and a compile error. 

```
enum Color
{
    red,
    green,
    blue, // blue is put into the global namespace
};

enum Feeling
{
    happy,
    tired,
    blue, // error: naming collision with the above blue
};
```

To avoid naming collisons:

- prefix each enumator with the name of the enumeration
- put the enumeration inside of a *namespace* for separate scope region (preferrred)

```
    namespace color
    {
        // The names Color, red, blue, and green are defined inside namespace color
        enum Color
        {
            red,
            green,
            blue,
        };
    }

    namespace feeling
    {
        enum Feeling
        {
            happy,
            tired,
            blue, // feeling::blue doesn't collide with color::blue
        };
    }

    int main()
    {
        color::Color paint { color::blue };
        feeling::Feeling me { feeling::blue };

        return 0;
    }
```

The 'color::Color' and 'color::blue' are examples of a *scope resolution operator*.

## Span
A span is a collection of items that are contiguous in memory. Provides a lightweight view over a contiguous sequence of objects. A span provides a safe way to iterate over and index into objects that are arranged back-to-back in memory. Such as objects stored in a built-in array, std::array, or std::vector.

If you typically access a sequence of back-to-back objects using a pointer and an index, a span is a safer, lightweight alternative.

The size of a span can be set at compile time by specifying it as a template argument, or at runtime by specifying dynamic_extent.

Unlike array or vector, a span doesn't "own" the elements inside it. A span doesn't free any storage for the items inside it because it doesn't own the storage for those objects.