# 0. Introduction

## C++ and CPP origins
C++ is one of the successors of C. Before C, most OS were written in Assembly. C was much better than Assembly and thus replaced as the de facto low level programming language for engineers. However, it lacked certain features as the tech market grew, the main being OOP construct. That is where C++ came in. C++ is also known as "C with class" and it was developed on Unix. C++ is perhaps best thought of as a superset of C, though this is not strictly true (as C99 introduced a few features that do not exist in C++).

The plus symbols can't be used in some situations, like in file names. Thus C++ is also known as CPP. File extensions that has .cpp are built with C++ source code. DOS and Windows C++ compilers use this file extension. 

The plus symbols can't be used in some situations, like in file names. Thus C++ is also known as CPP. File extensions that has .cpp are built with C++ source code. DOS and Windows C++ compilers use this file extension. 

## Application
C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of applications that most likely would be written in C++:

- Video games
- Real-time systems (e.g. for transportation, manufacturing, etc…
- High-performance financial applications (e.g. high frequency trading)
- Graphical applications and simulations
- Productivity / office applications
- IOT embedded software
- Audio and video processing
- Artificial intelligence and neural networks

In computer graphics, computer generated media tends to be structured, opposite of random and chaotic real life things.
CPP is also the GNU pre-processor.

## C++ compiling
In order to compile a C++ program, we use a C++ compiler. The C++ compiler sequentially goes through each source code in the **.cpp** file in your program. The compiler checks for errors and whether the source code compiles. Afterwards it translates the source code into a machine language file, called *object file*. Object files are typically named name.o or name.obj.

## Linker 
After the compiler creates one or more object files, then another program called the linker kicks in. The job of the linker is three fold:
1. Take all the object files generated by the compiler and combine them into a single executable program.
2. Link core and external libraries.
3. Make sure all cross-file dependencies are resolved properly

## Library
C++ also comes with an extensive library called the C++ Standard Library (usually shortened to standard library) that provides additional functionality that you can use in your programs. One of the most commonly used parts of the C++ standard library is the **iostream** library, which contains functionality for printing text on a monitor and getting keyboard input from a user. 

Almost every C++ program written utilizes the standard library in some form, so it’s very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn’t something you need to worry about.

## IDE
Install an IDE that comes with the latest C++ compiler. If not make sure it is at least has a C++17 capable compiler.

## Build Configuration
A build configuration or build target are configuration settings that determines how your project will be built. This includes basic things such as:

- name of executable file
- directories for IDE to look for libraries
- keep or strip debugging information
- level of optimization the compiler should check for

It is normally best to leave these at the default settings. There are two types of build configurations:

- Release configuration
- Debug configuration

Release configuration are settings to release code in production. Strips all debugging information but includes all the optimization methods for performance and size. Useful for performance testing the application in production. 
Debug configuration are settings to help debug your program. Turns off all optimization methods and includes the debugging information. This makes the program larger and slower but easier to debug. The debugging information is quite big and the difference between including and excluding it is quite substantial.

The build configuration type can easily be switched at the tool bar of your IDE which is usually at the top middle.

## Compiler Configuration

### Compiler Extensions
The standard C++ defines rules about how programs should behave in specific circumstances. While compilers follow these instructions most of the times, sometimes they will implement their own changes to the language. The purpose is to enhance compatibility with other versions of the language (e.g. C99). These compiler specific behaviors are called *compiler extensions*.

When you write a program with the compiler extension enabled, the program will be incompatible with the C++ standard. Programs that make use of non-standard extensions generally will not compile on other compilers that don't support these extensions. Even if they do, they may not run correectly. 

Keep in mind that compiler extensions are enabled by default. Thus unless you have a specific reason to use a certain compiler extension, they are not recommnded as they are non-compliant with C++ standards. They should be turned off at the start of the project. This will allow the program to be compliant with C++ standards and work on any system.

### Warning and Errors
If you have turned the compiler extensions off, the compiler will check if you follow the standard C++ rules. The compiler will search and identitfy and errors you make. In some cases, the compiler may find code that seems like it might be an error but not sure. This will issue a warning instead of an error, as there is a motto **trust the programmer**, which states that the compiler shouldn't prevent the programmer from doing what needs to be done. Typos can also register as warnings but serious errors can also be warnings so don't ignore them. 

There are ways in IDE to temporarily disable warnings but this is not recommended.

The warning level can be raised or lowered, meaning the compiler will be more sensitive or more relaxed when identifying possible errors. When starting out C++, it is best to set the level to max to help identify possible issues. You can also configure the compiler to treat warnings as errors. This is a good way to enforce programmers to fix all warnings, which many don't.

## C++ variations
There are many different versions of C++ (C++98, C++03, C++11, C++14, C++17, C++20, etc…). Your compiler will generally pick a standard to set as default. This is typically not the most recent language standard. To use a different language standard, you'll have to configure the IDE compiler to do so. 

Finalized language standards are named after the years in which they are finalized (e.g. C++17 was finalized in 2017). There are also in-progress language standards which are still in development and not clear in what year they will be finalized. For example, C++11 was caalled c++1x while it was under development.

In a professional environment, it is best to choose a language standard that is one or two versions back from the latest standard. As of this writing the latest version is C++20, thus you should choose C++14 or C++17. Several reasons to do this

- Compilers on some platforms may not provide full support for the latest standard right away
- Ensure the engineers have had the chance to fix any defects in the latest version 
- Allow best practices for new features to be discovered

In a learning environment, there is little downside to choosing the latest standard. 

As of the time of writing, Visual Studio 2022 defaults to C++14 capabilities, which does not allow for the use of newer features introduced in C++17 and C++20. To use these newer features, you’ll need to enable a newer language standard. Unfortunately, there is currently no way to do this globally -- you must do so on a project-by-project basis.

# 1. Basics

## Statement
A program is a sequence of instructions that tells the computer waht to do. A statement is a type of instruction that makes the program to do some action. 

Statements are the most common type of instruction in a C++ program. THey are the smallest unit of computation in C++. Most but not all statements in C++ end in a semicolon. Any line that ends in a semicolon is most likely a statement. 

This is in the context of C++. A single C++ statement may compile into dozens of machine language instructions.  

## main function
A function is a group of statements executed sequentially. A good developer will keep the size to a minimal and the logic as single as possible.

Just like Java, every C++ program must have a function called main. When the program is run all the statments inside of the main function are executed in sequential order. If the main function is absent from a program, it will compile but fail to build.

Example of main function in action:

    #include <iostream>

    int main()
    {
        std::cout << "Hello World!\n";
        return 0;
    }

There are quite a few syntax similarities to Java you see here.Some key terms to know from above:

- Line 1 is a special type of line called a **preprocessor directive**, indicates the use of **iostream** library contents
- Line 3 is the declaration of the main function, and indicates what type of data the function is returning
- Line 4 ~ 7 is the function body
- Line 5, 6 all have semicolons at the end, indiciating each of them are separate statements
- 

When compiled, the console will print the hello world statement and return 0.

## Comments
Comments exist soley for the programmer and devopers, as all comments are ignored by the compiler. Two types of comments:

- Single-line comments: begins with *//*. Typically used make a quick comment about a single line of code

Depending on the length, they can be either on the right side or the top of the code

- Multi-line comments: the /* and */ pair of symbols. Multi-line comments can't be nested.

Example:

    /* This is a multi-line comment.
    * the matching asterisks to the left
    * can make this easier to read
    */


## Objects
Like most programming langauges, direct memory access is discouraged and instead accessed indirectly via *object*. An object can be named or unnamed (anonymous). A named object is called a *variable* while the name of the object is called an *identifier*.

```
int x; // define a variable named x, of type int
```

Objects must be declared and a declaration statement is called a *definition*. 

At compile time, objects are not yet created but the compiler takes note that we are defining a certain variable with a certain name with its data type. Like Java the Object's data type must be known at compile time (static). 
At runtime, the object is created and assigned a memory address. This is called *instantiation* and an instantiated object is also called an *instance*.

## Declaration vs Definition
A *declaration* provides basic attributes of a symbol: its type and its name. A *definition* provides all of the details of that symbol -- if it's a function, what it does; if it's a class, what fields and methods it has; if it's a variable, where the variable gets stored. Thus memory for the variable is allocated during the definition of the variable.

In C language definition and declaration for a variable takes place at the same time. i.e. there is no difference between declaration and definition. 

## Defining multiple variables
It is possible to define multiple variables of the same type in a single statement by separating the names with a comma. The following code declares two variables of same integer type:

```
    int a, b;
```

You can't define variables of different types in the same statement. Variables of different types must be defined in separate statements.

```
    int a, double b; // wrong (compiler error)
    int a; double b; // correct (but not recommended)

    // correct and recommended (easier to read)
    int a;
    double b;
```

## Variable assignment and ininitialization
After defining a variable you can give it a value.

```
    #include <iostream>

    int main()
    {
        int width;
        width = 5; // copy assignment of value 5 into variable width

        // variable width now has value 5

        width = 7; // change value stored in variable width to 7

        // variable width now has value 7

        return 0;
    }
```

When no value is assigned to a value, it is called *default initializiation*. The variable references an undeterminate value. There are 4 basic ways to initialize variables in C++:
- default initializiation - nothing is assigned
- Copy initialization - assigned with =
- Direct initialization - assigned with ()
- Brace initialization - assigned with {}. modern way of initializing objects in C++

Declaration and initialization can be done on same one line:

```
    int a; // no initializer
    int b = 5; // initializer after equals sign
    int c( 6 ); // initializer in parenthesis
    int d { 7 }; // initializer in braces
```

Brace initialization doesn't allow *narrowing conversions*. This means that if you try to brace initialize a variable using a value that the variable can not safely hold, the compiler will produce an error. 

```
int width { 4.5 }; // error: a number with a fractional value can't fit into an int
```

If we tried copy and direct initialization, the compiler would simply drop the fractional part, resulting in the initialization of value 4 into variable width.'

## Value initialization and Zero initalization
When a variable is initialized with empty braces, *value initialization* takes place. In most cases, value initialization will initialize the variable to zero (or empty, if that’s more appropriate for a given type). 
This is useful when we want to create empty variables that is ready to accept an input.

*if a class is built-int, it will perform the same *value initialization*. But if the class is user-declared, it will invoke the dfault constructore.

## Multiple initialization
Like declarations, initialization of same types can be done on the same line. Keep in mind that all the variables on the line must be initialized, not just some:

```
    int a, b = 5; // wrong (a is not initialized!)
    int a = 5, b = 6; // copy initialization
    int c( 7 ), d( 8 ); // direct initialization
    int e { 9 }, f { 10 }; // brace initialization (preferred)
```

## IOStream library: output
As part of the C++ standard library that deals with IO. 

To print something, use *std::cout*, along with the *insertion operator* *<<,*

```
    #include <iostream> // for std::cout

    int main()
    {
        int x{ 5 };                         // define integer variable x, initialized with value 5
        std::cout << x;                     // print value of x (5) to console
        std::cout << "Hello" << " world!";  // print multiple things in one line
        return 0;
    }
```

Keep in mind that separate output statements don’t result in separate lines of output on the console. If we want to print separate lines of output to the console, we need to tell the console when to move the cursor to the next line using either  *std::endl* or the esacpe character '\n':

```
    #include <iostream> // for std::cout

    int main()
    {
        int x{ 5 };
        std::cout << "x is equal to: " << x << '\n';   // \n standalone, single quote needed
        std::cout << "And that's all, folks!\n";   // '\n' embedded, double quote needed
        return 0;
    }
```

For the standalone '\n', single quotes are needed. For the embedded '\n' above, double quotes are needed.

```
    #include <iostream> // for std::cout

    int main()
    {
        std::cout << "Hi!" << std::endl;
        std::cout << "My name is Alex." << std::endl;
        return 0;
    }
```

The second std::endl above isn’t technically necessary, since the program ends immediately afterward. However, it serves a few useful purposes:

- indicate that the line of output is a “complete thought” (as opposed to partial output that is completed somewhere later in the code). In this sense, it functions similarly to using a period in standard English.
- positions the cursor on the next line, so that if we later add additional lines of output (e.g. have the program say “bye!”), those lines will appear where we expect (rather then appended to the prior line of output).
- after running an executable from the command line, some operating systems do not output a new line before showing the command prompt again. If our program does not end with the cursor on a new line, the command prompt may appear appended to the prior line of output, rather than at the start of a new line as the user would expect.

*std::endl* does two jobs: it moves the cursor to the next line, and flushes the output. When writing text to the console using std::cout, std::cout often flushes output anyway. Thus we prefer *\n* and it is easier to read.

## IOStream library: input
*std::cin* (which stands for “character input”) reads input from keyboard using the *extraction operator* (>>). The input must be stored in a variable to be used thus this is where zero initialization comes in. Just like it is possible to output more than one bit of text in a single line, it is also possible to input more than one value on a single line:

```
    #include <iostream>  // for std::cout and std::cin

    int main()
    {
        std::cout << "Enter two number separated by a space: ";

        int x{ }; // define variable x to hold user input (and zero-initialize it)
        int y{ }; // define variable y to hold user input (and zero-initialize it)
        std::cin >> x >> y; 

        std::cout << "You entered " << x << " and " << y << '\n';
        return 0;
    }
```

Note that you don’t need to use ‘\n’ when accepting input, as the user will need to press the enter key to have their input accepted, and this will move the cursor to the next line.

*In line with our previous recommendation that *variables should always be initialized*, best practice is to initialize the variable first.

*The C++ I/O library does not provide a way to accept keyboard input without the user having to press enter. If this is something you desire, you’ll have to use a third party library.

## Initialized vs Uninitialized
C++ does not initialize most variables to a given value (zero) automatically. When a variable is given a memory address to store data, the default value is whatever garbage value that already happens to be in that memory address. A variable that hasn't been given a known value is called an uninitialied variable. 

Initialized is not the opposite of uninitialized. Initialized means the object was provided with an initial value at the time of definition and uninitilaized means the object has not been given a known value. If an uninitialized object is assigned a known value, it is no longer uninitialized. 

- Initialization = The object is given a known value at the point of definition.
- Assignment = The object is given a known value beyond the point of definition.
- Uninitialized = The object has not been given a known value yet.

This lack of initialization is a performance optimization inherited from C, back when computers were slow. Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.

If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (slow) and for little benefit (since you’re overwriting those values anyway).

For now, you should always initialize your variables because the cost of doing so is miniscule compared to the benefit. Once you are more comfortable with the language, there may be certain cases where you omit the initialization for optimization purposes. But this should always be done selectively and intentionally.

```
#include <iostream>

int main()
{
    // define an integer variable named x
    int x; // this variable is uninitialized because we haven't given it a value

    // print the value of x to the screen
    std::cout << x; // who knows what we'll get, because x is uninitialized

    return 0;
}
```

Most modern compilers will attempt to detect if a variable is being used without being given a value. The program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0. Otherwise, the compilers will be able to detect uninitialized variables, they will generally issue a compile-time error. For example, compiling the above program on Visual Studio produced the 'uninitialized local variable 'x' used' warning.

A nice trick to get around this is to make the compiler think we are assigning a value to the variable.

```
#include <iostream>

    void doNothing(int&) // does nothing
    {
    }

    int main()
    {
        // define an integer variable named x
        int x; // this variable is uninitialized

        doNothing(x); // make the compiler think we're assigning a value to this variable

        // print the value of x to the screen (who knows what we'll get, because x is uninitialized)
        std::cout << x;

        return 0;
    }
```

always initialize your variables!

## Undefined behavior
Using the value from an uninitialized variable is our first example of *undefined behavior*. Undefined behavior (often abbreviated UB) is the result of executing code whose behavior is not well defined by the C++ language. In this case, the C++ language doesn’t have any rules determining what happens if you use the value of a variable that has not been given a known value. Consequently, if you actually do this, undefined behavior will result.

Code implementing undefined behavior may exhibit any of the following symptoms:
- different results every time it is run.
- same incorrect result.
- inconsistent behavior (sometimes produces the correct result, sometimes not).
- seems like its working but produces incorrect results later in the program.
- program crashes, either immediately or later.
- program works on some compilers but not others.
- program works until you change some other seemingly unrelated code.

As a general rule of thumb, take care to avoid all situations that result in undefined behavior, such as using uninitialized variables.

## Keywords and Special identifiers
C++ has keywords and special identifiers: override, final, import, and module. While key words are reserved, special identifiers are not reserved. 

There are three different naming conventions:

- CamelCase
- snake_case
- pascalCase

C++ uses CamelCase like Java. 

Some things to keep in mind when naming:

- avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.
- avoid abbreviations
- avoid trivial an overly complex names

## Whitespace and Basic formatting
The C++ compiler generally ignores whitespaces thus we say that C++ is a whitespace-independent language. The following all do the exact same thing:

```
    std::cout << "Hello world!";

    std::cout               <<            "Hello world!";

            std::cout << 		"Hello world!";

    std::cout
        << "Hello world!";
```

For that reason, whitespaces and newlines are often used for code organization and readability.

The only exception is when whitespaces exist inside quoted text and comments. Newlines are not allowed in quoted text and comments:

```
    std::cout << "Hello
        world!"; // Not allowed!

    std::cout << "Hello "
        "world!"; // prints "Hello world!"

    std::cout << "Hello world!"; // Here is a single-line comment
    this is not part of the comment     
```

Because newlines and whitespaces only matter in quoted texts and comments, developers often do the following when declaring a function body: 

```
int main()
{
    std::cout << "Hello world!\n"; // tabbed in one tab (4 spaces)
    std::cout << "Nice to meet you.\n"; // tabbed in one tab (4 spaces)
}
```

Some more coding style conventions: 

- keep a single line no longer than 80 chars
- if the comment is above a code, there should be a new line above the comment
- if the comment is on the right hand side of the code, use whitespaces to align them
- use whitespace to make your code easier to read by aligning values

```
    cost          = 57;
    pricePerItem  = 24;
    value         = 5;
    numberOfItems = 17;
    std::cout << "Hello world!\n";                  // cout lives in the iostream library
    std::cout << "It is very nice to meet you!\n";  // these comments are easier to read
    std::cout << "Yeah!\n";                         // especially when all lined up

    // cout lives in the iostream library
    std::cout << "Hello world!\n";

    // these comments are easier to read
    std::cout << "It is very nice to meet you!\n";

    // when separated by whitespace
    std::cout << "Yeah!\n";
```

Using the automatic formatting feature is highly recommended to keep your code’s formatting style consistent. However, don't trust it completely as it sometimes may not choose the most readable formatting. Go over the code with your eyes for double checking. 

## Literals and Operators
A *literal* or a *constant* is a fixed value that has been directly inserted into the source code. Literals can't be changed while variable value's can be changed through initialization and assignment.

```
std::cout << "Hello world!";  // Hello world! is a literal
int x{ 5 };                   // 5 is a literal
```

Operators in C++ come in four different arities:

- Unary operators - act on one operand. An example is the negative operator
- Binary operators - act on two operands. The insertion (<<) and extraction (>>) operators are binary operators, taking std::cout or std::cin on the left side, and the value to output or variable to input to on the right side.
- Ternary operators - act on three operands. There is only one of these in C++ (the conditional operator), which we’ll cover later.
- Nullary operators - act on zero operands. There is also only one of these in C++ (the throw operator), which we’ll also cover later.

## Expression
An expression is a combination of literals, variables, operators, and function calls that *calculates a single value*. The process of executing an expression is called *evaluation*, and the single value produced is called the result of the expression.

Literals evaluate to their own values. 
Variables evaluate to the value of the variable.
Function calls evaluate to whatever value the function returns. 
Operators (such as operator+) let us combine multiple values together to produce a new value.

Expressions do not end in a semicolon, and cannot be compiled by themselves. Rather, expressions are always evaluated as part of statements. An *expression statement* is a statement that consists of an expression followed by a semicolon. When the statement is executed, the expression will be evaluated.

```
    // type identifier { expression };
    int x{ 2 + 3 };
```

An *expression statement* is a statement that consists of an expression followed by a semicolon. When the statement is executed, the expression will be evaluated.

An expression whose result is discarded is called a *discarded-value expression*. Expression statements are by far the most common type of discarded-value expressions.

# 2. Functions and Files

## Functions
A function is a reusable sequence of statements designed to do a particular job. Functions written yourself are called *user-defined functions*. When a function is called inside another FUNCTION, the CPU puts a bookmark at the current point of execution and executes the *called* function. When the called function ends, the CPU returns back to the point of book mark of the *caller* function and resumes execution.

The signature of the function is also called the *function header*.The curly braces and statements in-between are called the *function body*

Unlike some other languages like Python, C++ doesn't allow nested functions like the following:

```
    #include <iostream>

    int main()
    {
        void foo() // Illegal: this function is nested inside function main()
        {
            std::cout << "foo!\n";
        }

        foo(); // function call to foo()
        return 0;
    }
```

C++ disallows calling the main function explicitly and the main function should be at the bottom of your code module.

Functions should be minimal and only perform one type of action. If you see a block of code that is repeated, it is best to put that in a separate function and make calls to that function. This is follwoing the DRY best practice: *don’t repeat yourself*

```
    #include <iostream>
    int getValueFromUser() 
    {
        int input{};
        std::cout << "Enter an integer: ";
        std::cin >> input; 
        return input;
    }

    int main()
    {
        int x{ getValueFromUser() };
        int y{ getValueFromUser() };
        std::cout << x << " + " << y << " = " << x + y << '\n';
        return 0;
    }
```

## Return
C++ has a garbage collector for memory management. When a function terminates, all the value entered inside that function is lost. To save any data from that function, we have the *return* keyword to return a value or data. You can use that value in an expression or statement (by assigning to a variable or sending it somewhere). Otherwise it will be ignored. 

Of course we must save that returned value by assigning a variable to it. Otherwise it will get lost.

```
#include <iostream>

int getValueFromUser() // this function now returns an integer value
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value the user entered back to the caller
}

int main()
{
	int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

In the main function, a status code of 0 means the program executed successfully. 

In C++, a function can only return a single value.

## Void functions
